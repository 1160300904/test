package applications;

import GUI.LogSaver;
import appExceptions.FileInfoConflictException;
import appExceptions.FileSyntaxException;
import appExceptions.RepeatedObjectsException;
import centralObject.User;
import circularOrbit.CircularOrbit;
import circularOrbit.ConcreteCircularOrbit;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import physicalObject.PersonalApp;
import physicalObject.PersonalAppFactory;

public class PersonalAppEcosystem extends ConcreteCircularOrbit<User, PersonalApp> {
  // log info record
  private List<LogElement> inlog = new ArrayList<>();
  private List<LogElement> uninlog = new ArrayList<>();
  private List<LogElement> uselog = new ArrayList<>();
  private HashMap<LogElement, Integer> durations = new HashMap<>();
  // relation record
  private HashMap<String, HashSet<String>> relations = new HashMap<>();
  // base info record
  private String splitby;
  private String username;
  private HashMap<String, PersonalApp> apps = new HashMap<>();
  // simulate a phone
  private HashMap<String, List<Integer>> phone = new HashMap<>();
  // lists of usage conditions, each can generate a circular system.
  private List<List<AppUseNote>> ecos = new ArrayList<>();
  private List<MyDate> timenode = new ArrayList<>();

  // log
  LogSaver logsaver = LogSaver.getInstance();
  Logger log = logsaver.getLogger();

  /*
   * Abstract Function: 1.inlog represent the install log read from the file. 2.uninlog represent
   * the uninstall log initialized from the file. 3.uselog represent the use log initialized from
   * the file. 4.durations maps each useagelog to its useing duration. 5.relations represent the
   * relations between two apps initialized from the file. 6.splitby represents what strategy will
   * be used to split the time line of this phone. 7.username represents the user name of this
   * ecosystem. 8.apps is a map, which maps names of each app to itself. 9.phone is simulator of a
   * phone, we use it to simulate the install, uninstall, use operation to arrange the log from the
   * file, so that we can find out the details of each period of the phone. 10.ecos has the
   * infomation to generate a series of app ecosystem, which is generated by the function
   * ArrangeEcos() 11.timenode is a list of time node represents the split point in time of the
   * series of app ecosystems according to the file.
   */
  /*
   * Rep Invariant: 1.Null cannot exists in the inlog list. 2.Null cannot exists in the uninlog
   * list. 3.Null cannot exists in the uselog list. each element in this list, must exists in the
   * key set of duration map too. 4.the key and value in durations cannot be null. each element in
   * key set of duration map, must exists in the uselog list too. the integer value of duration map
   * must be positive. 5.for all the elements in the relation map, it cannot be null all the
   * elements in the relation map must exists in the key set of HashMap apps 6.splitby can only be
   * Hour|Day|Week|Month 7.each elements in apps map cannot be null. in map app, each string must
   * map to a personalapp has a name of itself.
   */

  void checkRep() {
    for (LogElement le : inlog) {
      assert le != null;
    }
    for (LogElement le : uninlog) {
      assert le != null;
    }
    Set<LogElement> durationKeySet = this.durations.keySet();
    for (LogElement le : uselog) {
      assert le != null;
      assert durationKeySet.contains(le);
    }
    for (LogElement le : durationKeySet) {
      assert le != null;
      assert this.uselog.contains(le);
      Integer in = durations.get(le);
      assert in != null;
      int i = in;
      assert i > 0;
    }

    Set<String> relationValueMap;
    Set<String> appKeySet = this.apps.keySet();
    for (String s1 : this.relations.keySet()) {
      assert s1 != null;
      assert appKeySet.contains(s1);
      relationValueMap = this.relations.get(s1);
      for (String s2 : relationValueMap) {
        assert s2 != null;
        assert appKeySet.contains(s2);
      }
    }
    assert splitby.equals("Hour") || splitby.equals("Day") || splitby.equals("Week")
        || splitby.equals("Month");
    for (String s : appKeySet) {
      assert s != null;
      PersonalApp pa = this.apps.get(s);
      assert pa.getName().equals(s);
    }
  }

  /**
   * initialize the app system from the file you provide. Then you can do other thing this
   * application provides.
   * 
   * @param file The file you offer to initiate.
   * @return true if the progress succeed.
   * @throws FileNotFoundException If the file cannot be found, throws FileNotFoundException
   * @throws FileSyntaxException If there are syntax errors in the file you provide, throws
   *         FileSyntaxException.
   * @throws RepeatedObjectsException If there are duplicated names in the file you provides, throws
   *         RepeatedObjectsException.
   */
  public long initFromFile(File file)
      throws FileNotFoundException, FileSyntaxException, RepeatedObjectsException {
    assert file != null;
    Scanner input = new Scanner(file);
    String str = null;
    int linenum = 1;
    // User ::= TimWong
    String userpstr = "User\\s*::=\\s*([[a-z][A-Z][0-9]]+)\\s*";
    Pattern userp = Pattern.compile(userpstr);
    // App ::= <Wechat,Tencent,13.2,"The most popular social networking App in
    // China","Social network">
    String apppstr =
        "App\\s*::=\\s*<([[a-z][A-Z][0-9]]+),([[a-z][A-Z][0-9]]+),([[a-z][A-Z][0-9]-_\\.]+),"
            + "(\"[[a-z][A-Z][0-9]\\s]+\"),(\"[[a-z][A-Z][0-9]\\s]+\")>\\s*";
    Pattern appp = Pattern.compile(apppstr);
    // InstallLog ::= <2019-01-01,13:00:00,Wechat>
    String intpstr = "InstallLog\\s*::=\\s*<\\s*([0-9]{4})-([0-9]{2})-([0-9]{2}),"
        + "([0-9]{2}):([0-9]{2}):([0-9]{2}),([[a-z][A-Z][0-9]]+)>";
    Pattern intp = Pattern.compile(intpstr);
    // UninstallLog ::= <2019-01-02,12:00:28,Eleme>
    String unintpstr = "UninstallLog\\s*::=\\s*<\\s*([0-9]{4})-([0-9]{2})-([0-9]{2}),"
        + "([0-9]{2}):([0-9]{2}):([0-9]{2}),([[a-z][A-Z][0-9]]+)>";
    Pattern unintp = Pattern.compile(unintpstr);
    // UsageLog ::= <2019-01-01,15:00:00,Wechat,2>
    String usepstr = "UsageLog\\s*::=\\s*<\\s*([0-9]{4})-([0-9]{2})-([0-9]{2}),"
        + "([0-9]{2}):([0-9]{2}):([0-9]{2}),([[a-z][A-Z][0-9]]+),([0-9]+)>";
    Pattern usep = Pattern.compile(usepstr);
    // Relation ::= <Wechat,QQ>
    String relpstr = "Relation\\s*::=\\s*<([[a-z][A-Z][0-9]]+),([[a-z][A-Z][0-9]]+)>\\s*";
    Pattern relp = Pattern.compile(relpstr);
    // Period ::= Day
    String perpstr = "Period\\s*::=\\s*(Hour|Day|Week|Month)\\s*";
    Pattern perp = Pattern.compile(perpstr);

    Matcher matcher;
    long begin=System.currentTimeMillis();
    while (input.hasNext()) {
      str = input.nextLine();
      if (str.matches(userpstr)) {
        matcher = userp.matcher(str);
        matcher.find();
        this.username = matcher.group(1);
        // System.out.println("username is:"+this.username);
      } else if (str.matches(apppstr)) {
        matcher = appp.matcher(str);
        matcher.find();
        String appname = matcher.group(1);
        String company = matcher.group(2);
        String version = matcher.group(3);
        String function = matcher.group(4);
        String businessarea = matcher.group(5);
        PersonalApp pa =
            PersonalAppFactory.getInstance(appname, company, version, function, businessarea);
        if (this.apps.put(appname, pa) != null) {
          String mes = "duplicated apps in the file: " + appname;
          LogRecord lr = new LogRecord(Level.INFO,
              "Exception" + ",RepeatedObjectsException," + mes + ",try again");
          this.log.log(lr);
          this.logsaver.add(lr);
          throw new RepeatedObjectsException(mes);
        }

        /*
         * System.out.println(matcher.group(1)+"    "+matcher.group(2)+"   "+matcher. group(3));
         * System.out.println(matcher.group(4)); System.out.println(matcher.group(5));
         */
      } else if (str.matches(intpstr)) {
        matcher = intp.matcher(str);
        matcher.find();
        int year = Integer.valueOf(matcher.group(1));
        int month = Integer.valueOf(matcher.group(2));
        int day = Integer.valueOf(matcher.group(3));
        int hour = Integer.valueOf(matcher.group(4));
        int minute = Integer.valueOf(matcher.group(5));
        int second = Integer.valueOf(matcher.group(6));
        String appname = matcher.group(7);
        MyDate d = new MyDate(year, month, day, hour, minute, second);
        LogElement le = new LogElement(appname, d);
        this.inlog.add(le);
        // System.out.println("install: "+le.toString());
      } else if (str.matches(unintpstr)) {
        matcher = unintp.matcher(str);
        matcher.find();
        int year = Integer.valueOf(matcher.group(1));
        int month = Integer.valueOf(matcher.group(2));
        int day = Integer.valueOf(matcher.group(3));
        int hour = Integer.valueOf(matcher.group(4));
        int minute = Integer.valueOf(matcher.group(5));
        int second = Integer.valueOf(matcher.group(6));
        String appname = matcher.group(7);
        MyDate d = new MyDate(year, month, day, hour, minute, second);
        LogElement le = new LogElement(appname, d);
        this.uninlog.add(le);
        // System.out.println("uninstall: "+le.toString());
      } else if (str.matches(usepstr)) {
        matcher = usep.matcher(str);
        matcher.find();
        int year = Integer.valueOf(matcher.group(1));
        int month = Integer.valueOf(matcher.group(2));
        int day = Integer.valueOf(matcher.group(3));
        int hour = Integer.valueOf(matcher.group(4));
        int minute = Integer.valueOf(matcher.group(5));
        int second = Integer.valueOf(matcher.group(6));
        String appname = matcher.group(7);
        int duration = Integer.valueOf(matcher.group(8));

        MyDate d = new MyDate(year, month, day, hour, minute, second);
        LogElement le = new LogElement(appname, d);
        this.uselog.add(le);
        this.durations.put(le, duration);
        // System.out.println("use: "+le.toString()+" for "+duration+" minutes.");
      } else if (str.matches(relpstr)) {
        matcher = relp.matcher(str);
        matcher.find();
        String s1 = matcher.group(1);
        String s2 = matcher.group(2);
        this.addRelation(s1, s2);
        this.addRelation(s2, s1);

      } else if (str.matches(perpstr)) {
        matcher = perp.matcher(str);
        matcher.find();
        this.splitby = matcher.group(1);
      } else if (str.matches("")) {
        //
      } else {
        System.out.println(linenum + ": " + str);
        String mes = "FileSyntaxException: " + str;
        LogRecord lr =
            new LogRecord(Level.INFO, "Exception" + ",FileSyntaxException," + mes + ",try again");
        this.log.log(lr);
        this.logsaver.add(lr);
        throw new FileSyntaxException(str);
      }
      // System.out.println(linenum+": "+str);
      linenum++;

    }
    input.close();
    //checkRep();
    /*
     * debug System.out.println();System.out.println();System.out.println(); for(LogElement
     * le:this.inlog) { System.out.println(le.toString()); } System.out.println(); for(LogElement
     * le:this.uninlog) { System.out.println(le.toString()); } System.out.println(); for(LogElement
     * le:this.uselog) { System.out.println(le.toString()); } System.out.println();
     * for(Entry<LogElement,Integer> e:this.durations.entrySet()) {
     * System.out.println(e.getKey().getName()+" for "+e.getValue()); } System.out.println();
     * for(String s:this.relations.keySet()) { HashSet<String> set=this.relations.get(s); for(String
     * s1:set) { System.out.println(s+" "+s1); } } System.out.println();
     * System.out.println(this.splitby);
     */
    return System.currentTimeMillis()-begin;
  }
  
  /**
   * initialize the app system from the file you provide. Then you can do other thing this
   * application provides.
   * 
   * @param file The file you offer to initiate.
   * @return true if the progress succeed.
   * @throws FileSyntaxException If there are syntax errors in the file you provide, throws
   *         FileSyntaxException.
   * @throws RepeatedObjectsException If there are duplicated names in the file you provides, throws
   *         RepeatedObjectsException.
   * @throws IOException 
   */
  public long initFromFileBuffered(File file)
      throws FileSyntaxException, RepeatedObjectsException, IOException {
    assert file != null;
    BufferedReader input=new BufferedReader(new InputStreamReader(new FileInputStream(file)));
    int linenum = 1;
    // User ::= TimWong
    String userpstr = "User\\s*::=\\s*([[a-z][A-Z][0-9]]+)\\s*";
    Pattern userp = Pattern.compile(userpstr);
    // App ::= <Wechat,Tencent,13.2,"The most popular social networking App in
    // China","Social network">
    String apppstr =
        "App\\s*::=\\s*<([[a-z][A-Z][0-9]]+),([[a-z][A-Z][0-9]]+),([[a-z][A-Z][0-9]-_\\.]+),"
            + "(\"[[a-z][A-Z][0-9]\\s]+\"),(\"[[a-z][A-Z][0-9]\\s]+\")>\\s*";
    Pattern appp = Pattern.compile(apppstr);
    // InstallLog ::= <2019-01-01,13:00:00,Wechat>
    String intpstr = "InstallLog\\s*::=\\s*<\\s*([0-9]{4})-([0-9]{2})-([0-9]{2}),"
        + "([0-9]{2}):([0-9]{2}):([0-9]{2}),([[a-z][A-Z][0-9]]+)>";
    Pattern intp = Pattern.compile(intpstr);
    // UninstallLog ::= <2019-01-02,12:00:28,Eleme>
    String unintpstr = "UninstallLog\\s*::=\\s*<\\s*([0-9]{4})-([0-9]{2})-([0-9]{2}),"
        + "([0-9]{2}):([0-9]{2}):([0-9]{2}),([[a-z][A-Z][0-9]]+)>";
    Pattern unintp = Pattern.compile(unintpstr);
    // UsageLog ::= <2019-01-01,15:00:00,Wechat,2>
    String usepstr = "UsageLog\\s*::=\\s*<\\s*([0-9]{4})-([0-9]{2})-([0-9]{2}),"
        + "([0-9]{2}):([0-9]{2}):([0-9]{2}),([[a-z][A-Z][0-9]]+),([0-9]+)>";
    Pattern usep = Pattern.compile(usepstr);
    // Relation ::= <Wechat,QQ>
    String relpstr = "Relation\\s*::=\\s*<([[a-z][A-Z][0-9]]+),([[a-z][A-Z][0-9]]+)>\\s*";
    Pattern relp = Pattern.compile(relpstr);
    // Period ::= Day
    String perpstr = "Period\\s*::=\\s*(Hour|Day|Week|Month)\\s*";
    Pattern perp = Pattern.compile(perpstr);

    Matcher matcher;
    long begin=System.currentTimeMillis();
    String str = input.readLine();
    while (str!=null) {
      if (str.matches(userpstr)) {
        matcher = userp.matcher(str);
        matcher.find();
        this.username = matcher.group(1);
        // System.out.println("username is:"+this.username);
      } else if (str.matches(apppstr)) {
        matcher = appp.matcher(str);
        matcher.find();
        String appname = matcher.group(1);
        String company = matcher.group(2);
        String version = matcher.group(3);
        String function = matcher.group(4);
        String businessarea = matcher.group(5);
        PersonalApp pa =
            PersonalAppFactory.getInstance(appname, company, version, function, businessarea);
        if (this.apps.put(appname, pa) != null) {
          String mes = "duplicated apps in the file: " + appname;
          LogRecord lr = new LogRecord(Level.INFO,
              "Exception" + ",RepeatedObjectsException," + mes + ",try again");
          this.log.log(lr);
          this.logsaver.add(lr);
          throw new RepeatedObjectsException(mes);
        }

        /*
         * System.out.println(matcher.group(1)+"    "+matcher.group(2)+"   "+matcher. group(3));
         * System.out.println(matcher.group(4)); System.out.println(matcher.group(5));
         */
      } else if (str.matches(intpstr)) {
        matcher = intp.matcher(str);
        matcher.find();
        int year = Integer.valueOf(matcher.group(1));
        int month = Integer.valueOf(matcher.group(2));
        int day = Integer.valueOf(matcher.group(3));
        int hour = Integer.valueOf(matcher.group(4));
        int minute = Integer.valueOf(matcher.group(5));
        int second = Integer.valueOf(matcher.group(6));
        String appname = matcher.group(7);
        MyDate d = new MyDate(year, month, day, hour, minute, second);
        LogElement le = new LogElement(appname, d);
        this.inlog.add(le);
        // System.out.println("install: "+le.toString());
      } else if (str.matches(unintpstr)) {
        matcher = unintp.matcher(str);
        matcher.find();
        int year = Integer.valueOf(matcher.group(1));
        int month = Integer.valueOf(matcher.group(2));
        int day = Integer.valueOf(matcher.group(3));
        int hour = Integer.valueOf(matcher.group(4));
        int minute = Integer.valueOf(matcher.group(5));
        int second = Integer.valueOf(matcher.group(6));
        String appname = matcher.group(7);
        MyDate d = new MyDate(year, month, day, hour, minute, second);
        LogElement le = new LogElement(appname, d);
        this.uninlog.add(le);
        // System.out.println("uninstall: "+le.toString());
      } else if (str.matches(usepstr)) {
        matcher = usep.matcher(str);
        matcher.find();
        int year = Integer.valueOf(matcher.group(1));
        int month = Integer.valueOf(matcher.group(2));
        int day = Integer.valueOf(matcher.group(3));
        int hour = Integer.valueOf(matcher.group(4));
        int minute = Integer.valueOf(matcher.group(5));
        int second = Integer.valueOf(matcher.group(6));
        String appname = matcher.group(7);
        int duration = Integer.valueOf(matcher.group(8));

        MyDate d = new MyDate(year, month, day, hour, minute, second);
        LogElement le = new LogElement(appname, d);
        this.uselog.add(le);
        this.durations.put(le, duration);
        // System.out.println("use: "+le.toString()+" for "+duration+" minutes.");
      } else if (str.matches(relpstr)) {
        matcher = relp.matcher(str);
        matcher.find();
        String s1 = matcher.group(1);
        String s2 = matcher.group(2);
        this.addRelation(s1, s2);
        this.addRelation(s2, s1);

      } else if (str.matches(perpstr)) {
        matcher = perp.matcher(str);
        matcher.find();
        this.splitby = matcher.group(1);
      } else if (str.matches("")) {
        //
      } else {
        System.out.println(linenum + ": " + str);
        String mes = "FileSyntaxException: " + str;
        LogRecord lr =
            new LogRecord(Level.INFO, "Exception" + ",FileSyntaxException," + mes + ",try again");
        this.log.log(lr);
        this.logsaver.add(lr);
        throw new FileSyntaxException(str);
      }
      // System.out.println(linenum+": "+str);
      linenum++;
      str=input.readLine();
    }
    input.close();
    //checkRep();
    /*
     * debug System.out.println();System.out.println();System.out.println(); for(LogElement
     * le:this.inlog) { System.out.println(le.toString()); } System.out.println(); for(LogElement
     * le:this.uninlog) { System.out.println(le.toString()); } System.out.println(); for(LogElement
     * le:this.uselog) { System.out.println(le.toString()); } System.out.println();
     * for(Entry<LogElement,Integer> e:this.durations.entrySet()) {
     * System.out.println(e.getKey().getName()+" for "+e.getValue()); } System.out.println();
     * for(String s:this.relations.keySet()) { HashSet<String> set=this.relations.get(s); for(String
     * s1:set) { System.out.println(s+" "+s1); } } System.out.println();
     * System.out.println(this.splitby);
     */
    return System.currentTimeMillis()-begin;
  }
  
  /**
   * initialize the app system from the file you provide. Then you can do other thing this
   * application provides.
   * 
   * @param file The file you offer to initiate.
   * @return true if the progress succeed.
   * @throws FileSyntaxException If there are syntax errors in the file you provide, throws
   *         FileSyntaxException.
   * @throws RepeatedObjectsException If there are duplicated names in the file you provides, throws
   *         RepeatedObjectsException.
   * @throws IOException If an I/O error occurs.
   */
  public long initFromFileBufferedReader(File file)
      throws FileSyntaxException, RepeatedObjectsException, IOException {
    assert file != null;
    BufferedReader input=new BufferedReader(new FileReader(file));
    int linenum = 1;
    // User ::= TimWong
    String userpstr = "User\\s*::=\\s*([[a-z][A-Z][0-9]]+)\\s*";
    Pattern userp = Pattern.compile(userpstr);
    // App ::= <Wechat,Tencent,13.2,"The most popular social networking App in
    // China","Social network">
    String apppstr =
        "App\\s*::=\\s*<([[a-z][A-Z][0-9]]+),([[a-z][A-Z][0-9]]+),([[a-z][A-Z][0-9]-_\\.]+),"
            + "(\"[[a-z][A-Z][0-9]\\s]+\"),(\"[[a-z][A-Z][0-9]\\s]+\")>\\s*";
    Pattern appp = Pattern.compile(apppstr);
    // InstallLog ::= <2019-01-01,13:00:00,Wechat>
    String intpstr = "InstallLog\\s*::=\\s*<\\s*([0-9]{4})-([0-9]{2})-([0-9]{2}),"
        + "([0-9]{2}):([0-9]{2}):([0-9]{2}),([[a-z][A-Z][0-9]]+)>";
    Pattern intp = Pattern.compile(intpstr);
    // UninstallLog ::= <2019-01-02,12:00:28,Eleme>
    String unintpstr = "UninstallLog\\s*::=\\s*<\\s*([0-9]{4})-([0-9]{2})-([0-9]{2}),"
        + "([0-9]{2}):([0-9]{2}):([0-9]{2}),([[a-z][A-Z][0-9]]+)>";
    Pattern unintp = Pattern.compile(unintpstr);
    // UsageLog ::= <2019-01-01,15:00:00,Wechat,2>
    String usepstr = "UsageLog\\s*::=\\s*<\\s*([0-9]{4})-([0-9]{2})-([0-9]{2}),"
        + "([0-9]{2}):([0-9]{2}):([0-9]{2}),([[a-z][A-Z][0-9]]+),([0-9]+)>";
    Pattern usep = Pattern.compile(usepstr);
    // Relation ::= <Wechat,QQ>
    String relpstr = "Relation\\s*::=\\s*<([[a-z][A-Z][0-9]]+),([[a-z][A-Z][0-9]]+)>\\s*";
    Pattern relp = Pattern.compile(relpstr);
    // Period ::= Day
    String perpstr = "Period\\s*::=\\s*(Hour|Day|Week|Month)\\s*";
    Pattern perp = Pattern.compile(perpstr);

    Matcher matcher;
    long begin=System.currentTimeMillis();
    String str = input.readLine();
    while (str!=null) {
      if (str.matches(userpstr)) {
        matcher = userp.matcher(str);
        matcher.find();
        this.username = matcher.group(1);
        // System.out.println("username is:"+this.username);
      } else if (str.matches(apppstr)) {
        matcher = appp.matcher(str);
        matcher.find();
        String appname = matcher.group(1);
        String company = matcher.group(2);
        String version = matcher.group(3);
        String function = matcher.group(4);
        String businessarea = matcher.group(5);
        PersonalApp pa =
            PersonalAppFactory.getInstance(appname, company, version, function, businessarea);
        if (this.apps.put(appname, pa) != null) {
          String mes = "duplicated apps in the file: " + appname;
          LogRecord lr = new LogRecord(Level.INFO,
              "Exception" + ",RepeatedObjectsException," + mes + ",try again");
          this.log.log(lr);
          this.logsaver.add(lr);
          throw new RepeatedObjectsException(mes);
        }

        /*
         * System.out.println(matcher.group(1)+"    "+matcher.group(2)+"   "+matcher. group(3));
         * System.out.println(matcher.group(4)); System.out.println(matcher.group(5));
         */
      } else if (str.matches(intpstr)) {
        matcher = intp.matcher(str);
        matcher.find();
        int year = Integer.valueOf(matcher.group(1));
        int month = Integer.valueOf(matcher.group(2));
        int day = Integer.valueOf(matcher.group(3));
        int hour = Integer.valueOf(matcher.group(4));
        int minute = Integer.valueOf(matcher.group(5));
        int second = Integer.valueOf(matcher.group(6));
        String appname = matcher.group(7);
        MyDate d = new MyDate(year, month, day, hour, minute, second);
        LogElement le = new LogElement(appname, d);
        this.inlog.add(le);
        // System.out.println("install: "+le.toString());
      } else if (str.matches(unintpstr)) {
        matcher = unintp.matcher(str);
        matcher.find();
        int year = Integer.valueOf(matcher.group(1));
        int month = Integer.valueOf(matcher.group(2));
        int day = Integer.valueOf(matcher.group(3));
        int hour = Integer.valueOf(matcher.group(4));
        int minute = Integer.valueOf(matcher.group(5));
        int second = Integer.valueOf(matcher.group(6));
        String appname = matcher.group(7);
        MyDate d = new MyDate(year, month, day, hour, minute, second);
        LogElement le = new LogElement(appname, d);
        this.uninlog.add(le);
        // System.out.println("uninstall: "+le.toString());
      } else if (str.matches(usepstr)) {
        matcher = usep.matcher(str);
        matcher.find();
        int year = Integer.valueOf(matcher.group(1));
        int month = Integer.valueOf(matcher.group(2));
        int day = Integer.valueOf(matcher.group(3));
        int hour = Integer.valueOf(matcher.group(4));
        int minute = Integer.valueOf(matcher.group(5));
        int second = Integer.valueOf(matcher.group(6));
        String appname = matcher.group(7);
        int duration = Integer.valueOf(matcher.group(8));

        MyDate d = new MyDate(year, month, day, hour, minute, second);
        LogElement le = new LogElement(appname, d);
        this.uselog.add(le);
        this.durations.put(le, duration);
        // System.out.println("use: "+le.toString()+" for "+duration+" minutes.");
      } else if (str.matches(relpstr)) {
        matcher = relp.matcher(str);
        matcher.find();
        String s1 = matcher.group(1);
        String s2 = matcher.group(2);
        this.addRelation(s1, s2);
        this.addRelation(s2, s1);

      } else if (str.matches(perpstr)) {
        matcher = perp.matcher(str);
        matcher.find();
        this.splitby = matcher.group(1);
      } else if (str.matches("")) {
        //
      } else {
        System.out.println(linenum + ": " + str);
        String mes = "FileSyntaxException: " + str;
        LogRecord lr =
            new LogRecord(Level.INFO, "Exception" + ",FileSyntaxException," + mes + ",try again");
        this.log.log(lr);
        this.logsaver.add(lr);
        throw new FileSyntaxException(str);
      }
      // System.out.println(linenum+": "+str);
      linenum++;
      str = input.readLine();
    }
    input.close();
    //checkRep();
    /*
     * debug System.out.println();System.out.println();System.out.println(); for(LogElement
     * le:this.inlog) { System.out.println(le.toString()); } System.out.println(); for(LogElement
     * le:this.uninlog) { System.out.println(le.toString()); } System.out.println(); for(LogElement
     * le:this.uselog) { System.out.println(le.toString()); } System.out.println();
     * for(Entry<LogElement,Integer> e:this.durations.entrySet()) {
     * System.out.println(e.getKey().getName()+" for "+e.getValue()); } System.out.println();
     * for(String s:this.relations.keySet()) { HashSet<String> set=this.relations.get(s); for(String
     * s1:set) { System.out.println(s+" "+s1); } } System.out.println();
     * System.out.println(this.splitby);
     */
    return System.currentTimeMillis()-begin;
  }

  /**
   * Add relations between the two objects you provides. It doesn't refer to a specific circular
   * orbit, It means the relations in the global perspective.
   * 
   * @param s1 One object you want to add relation with.
   * @param s2 Another object you want to add relation with.
   * @return true if the progress succeed. False otherwise.
   */
  private boolean addRelation(String s1, String s2) {
    assert s1.equals("") == false;
    assert s2.equals("") == false;
    assert this.apps.keySet().contains(s1);
    assert this.apps.keySet().contains(s2);
    HashSet<String> relset = this.relations.get(s1);
    if (relset == null) {
      relset = new HashSet<>();
      this.relations.put(s1, relset);
    }
    return relset.add(s2);
  }

  /**
   * Test if two objects are related with each other.
   * 
   * @param s1 One object you want to test with.
   * @param s2 Another object you want to test with.
   * @return true if these two objecds are related with each other, false otherwise.
   */
  public boolean isRelated(String s1, String s2) {
    HashSet<String> relset = this.relations.get(s1);
    if (relset == null) {
      return false;
    }
    return relset.contains(s2);
  }

  /**
   * Get an unmodifiable map view of the relations between objects in the personal app ecosystem.
   * 
   * @return an unmodifiable map view of the relations between objects in the personal app
   *         ecosystem.
   */
  public Map<String, HashSet<String>> getRelationMap() {
    return Collections.unmodifiableMap(this.relations);
  }

  /**
   * Given three indices, get the earliest MyDate by returning 1, or 2, or 3. 1 means the first
   * list, 2 mean the second, 3 means the third.
   * 
   * @param i index of list 1.
   * @param j index of list 2.
   * @param k index of list 3.
   * @param is size of list 1.
   * @param js size of list 2.
   * @param ks size of list 3.
   * @return 1, or 2, or 3 which means the list sequence number which has the earliest MyDate. 1
   *         means the first list,2 mean the second, 3 means the third.
   */
  public int getMinMyDate(int i, int j, int k, int is, int js, int ks) {
    if (i < is && j < js && k < ks) {
      MyDate di = this.inlog.get(i).getDate();
      MyDate dj = this.uninlog.get(j).getDate();
      MyDate dk = this.uselog.get(k).getDate();
      return MyDate.getMin(di, dj, dk);
    }
    if (i < is && j < js && k >= ks) {
      MyDate di = this.inlog.get(i).getDate();
      MyDate dj = this.uninlog.get(j).getDate();
      if (di.compareTo(dj) <= 0) {
        return 1;
      } else {
        return 2;
      }
    }
    if (i < is && j >= js && k < ks) {
      MyDate di = this.inlog.get(i).getDate();
      MyDate dk = this.uselog.get(k).getDate();
      if (di.compareTo(dk) <= 0) {
        return 1;
      } else {
        return 3;
      }
    }
    if (i >= is && j < js && k < ks) {
      MyDate dk = this.uselog.get(k).getDate();
      MyDate dj = this.uninlog.get(j).getDate();
      if (dk.compareTo(dj) <= 0) {
        return 3;
      } else {
        return 2;
      }
    }
    if (i < is && j >= js && k >= ks) {
      return 1;
    }
    if (i >= is && j < js && k >= ks) {
      return 2;
    }
    return 3;
  }

  /**
   * arrange the personal app ecosystem according to the informations read from the file.
   * 
   * @throws FileInfoConflictException If the file information is conflict in itself, throw
   *         FileInfoConflictException.
   */
  public void arrangeEcos() throws FileInfoConflictException {
    Collections.sort(this.inlog);
    Collections.sort(this.uninlog);
    Collections.sort(this.uselog);
    /*
     * for(LogElement le:this.inlog) { System.out.println(le.toString());
     * }System.out.println();System.out.println();System.out.println(); for(LogElement
     * le:this.uninlog) { System.out.println(le.toString());
     * }System.out.println();System.out.println();System.out.println(); for(LogElement
     * le:this.uselog) { System.out.println(le.toString());
     * }System.out.println();System.out.println();System.out.println();
     */
    int inindex = 0;
    int uninindex = 0;
    int useindex = 0;
    int insize = this.inlog.size();
    int uninsize = this.uninlog.size();
    int usesize = this.uselog.size();
    // System.out.println(insize+" "+uninsize+" "+usesize);
    int min;
    HashMap<String, Integer> fremap = new HashMap<>();
    HashMap<String, Integer> timemap = new HashMap<>();
   
    /*replaced by HashMapPool
     *  HashMapPool pool=new HashMapPool();
    HashMap<String, Integer> fremap = pool.getHashMap();
    HashMap<String, Integer> timemap = pool.getHashMap();
     */
    // 1.find the min time for the total log.
    min = getMinMyDate(inindex, uninindex, useindex, insize, uninsize, usesize);
    MyDate periodend;
    MyDate handdate;
    /*
     * if(min==1) { periodend=this.inlog.get(0).getDate(); }else if(min==2) {
     * periodend=this.uninlog.get(0).getDate(); }else { periodend=this.uselog.get(0).getDate(); }
     */
    periodend = this.inlog.get(0).getDate();
    // truncate the time
    periodend = MyDate.truncBaseOnSplit(splitby, periodend);
    this.timenode.add(periodend);
    periodend = MyDate.addBaseOnSplit(splitby, periodend);
    // simulate the phone
    while (inindex < insize || uninindex < uninsize || useindex < usesize) {
      min = getMinMyDate(inindex, uninindex, useindex, insize, uninsize, usesize);
      if (min == 1) {
        handdate = this.inlog.get(inindex).getDate();
      } else if (min == 2) {
        handdate = this.uninlog.get(uninindex).getDate();
      } else {
        handdate = this.uselog.get(useindex).getDate();
      }
      if (handdate.compareTo(periodend) > 0) {
        // zhengli
        // ending of a period
        this.clear(fremap, periodend, timemap);
        fremap = new HashMap<>();
        timemap = new HashMap<>();
        /*
         * 
        pool.returnHashMap(fremap);fremap=pool.getHashMap();
        pool.returnHashMap(timemap);timemap=pool.getHashMap();
         */
        this.timenode.add(periodend);
        periodend = MyDate.addBaseOnSplit(splitby, periodend);
      }

      if (min == 1) {
        installSimu(inindex++);
      } else if (min == 2) {
        uninstallSimu(uninindex++, fremap, timemap);
      } else {
        useSimu(useindex++);
      }

    }
    this.clear(fremap, periodend, timemap);
    this.timenode.add(periodend);
  }

  /**
   * Get the informations of the ecosystem arranged by the method ArrangeEcos(), it can be used to
   * draw a sequence of circular orbit of app ecosystems.
   * 
   * @return
   */
  public List<List<AppUseNote>> getEcos() {
    return Collections.unmodifiableList(this.ecos);
  }

  /**
   * Get the time stamp of each period of the app ecosystems. For each two time stamps, one is the
   * beginning of a period, the other is the ending of the period.
   * 
   * @return the time stamp of each period of the app ecosystems.
   */
  public List<MyDate> getPeriodList() {
    return Collections.unmodifiableList(this.timenode);
  }

  /**
   * Get a map which maps Name of each PersonalApp to itself.
   * 
   * @return a map which maps Name of each PersonalApp to itself.
   */
  public Map<String, PersonalApp> getUseNoteToAppMap() {
    return Collections.unmodifiableMap(this.apps);
  }

  /**
   * Get the user name of this app ecosystem.
   * 
   * @return the user name of this app ecosystem
   */
  public String getUserName() {
    return this.username;
  }
  
  /**
   * clear up the phone and add a new element with the information of the phone into the list of
   * ecos.
   * 
   * @param fremap      frequency map with informations.
   * @param periodend   end of this period 
   * @param timemap     time map with informations.
   */
  private void clear(HashMap<String, Integer> fremap, MyDate periodend,
      HashMap<String, Integer> timemap) {
    List<Integer> uselist;
    List<AppUseNote> usenoteoneperiod;
    for (String name : phone.keySet()) {
      uselist = phone.get(name);
      this.mergeSingle(name, uselist, fremap, timemap);
      phone.put(name, new ArrayList<Integer>());
    }
    usenoteoneperiod = new ArrayList<AppUseNote>();
    for (String name : fremap.keySet()) {
      int freq = fremap.get(name);
      int time = timemap.get(name);
      AppUseNote usenote = new AppUseNote(freq, time, name);
      usenoteoneperiod.add(usenote);
    }
    this.ecos.add(usenoteoneperiod);

  }

  /**
   * simulate installing in the phone.
   * 
   * @param inindex the index of the log in the install log list.
   * @return true if the progress succeed, false otherwise.
   * @throws FileInfoConflictException 1.the app didn't declared in the file. 2.the app is installed
   *         more than once.
   */
  private boolean installSimu(int inindex) throws FileInfoConflictException {
    LogElement le = this.inlog.get(inindex);
    String lename = le.getName();
    if (this.apps.keySet().contains(lename) == false) {
      String mes = lename + " is not declared in the file.";
      LogRecord lr = new LogRecord(Level.INFO,
          "Exception" + ",FileInfoConflictException," + mes + ",try again");
      this.log.log(lr);
      this.logsaver.add(lr);
      throw new FileInfoConflictException(mes);
    }
    if (this.phone.put(lename, new ArrayList<Integer>()) != null) {
      String mes = lename + " is already installed in the phone.";
      LogRecord lr = new LogRecord(Level.INFO,
          "Exception" + ",FileInfoConflictException," + mes + ",try again");
      this.log.log(lr);
      this.logsaver.add(lr);
      throw new FileInfoConflictException(mes);
    }
    return true;
  }

  /**
   * simulate using apps in the phone.
   * 
   * @param inindex the index of the log in the useing log list.
   * @return true if the progress succeed, false otherwise.
   * @throws FileInfoConflictException 1.the app didn't declared in the file. 2.the app is used
   *         before install.
   */
  private boolean useSimu(int useindex) throws FileInfoConflictException {
    LogElement le = this.uselog.get(useindex);
    String name = le.getName();
    if (this.apps.keySet().contains(name) == false) {
      String mes = name + " is not declared in the file.";
      LogRecord lr = new LogRecord(Level.INFO,
          "Exception" + ",FileInfoConflictException," + mes + ",try again");
      this.log.log(lr);
      this.logsaver.add(lr);
      throw new FileInfoConflictException(mes);
    }
    /*
     * debug Integer i=durations.get(le); if(i==null) { System.out.println("null"); } int dur=i;
     */
    int dur = durations.get(le);
    List<Integer> uselist;
    if ((uselist = phone.get(name)) == null) {
      String mes = name + " is not installed in the phone currently when use it.";
      System.out.println(le.toString());
      LogRecord lr = new LogRecord(Level.INFO,
          "Exception" + ",FileInfoConflictException," + mes + ",try again");
      this.log.log(lr);
      this.logsaver.add(lr);
      throw new FileInfoConflictException(mes);
    }
    uselist.add(dur);
    return true;
  }

  /**
   * simulate uninstalling apps in the phone.
   * 
   * @param inindex the index of the log in the uninstall log list.
   * @return true if the progress succeed, false otherwise.
   * @throws FileInfoConflictException 1.the app didn't declared in the file. 2.the app is
   *         uninstalled more than once.
   */
  private boolean uninstallSimu(int uninindex, HashMap<String, Integer> fremap,
      HashMap<String, Integer> timemap) throws FileInfoConflictException {
    String name = this.uninlog.get(uninindex).getName();
    if (this.apps.keySet().contains(name) == false) {
      String mes = name + " is not declared in the file.";
      LogRecord lr = new LogRecord(Level.INFO,
          "Exception" + ",FileInfoConflictException," + mes + ",try again");
      this.log.log(lr);
      this.logsaver.add(lr);
      throw new FileInfoConflictException(mes);
    }
    List<Integer> uselist;
    if ((uselist = phone.get(name)) == null) {
      String mes = name + " is already uninstalled from the phone.";
      LogRecord lr = new LogRecord(Level.INFO,
          "Exception" + ",FileInfoConflictException," + mes + ",try again");
      this.log.log(lr);
      this.logsaver.add(lr);
      throw new FileInfoConflictException(mes);
    }
    phone.remove(name);
    this.mergeSingle(name, uselist, fremap, timemap);
    return true;
  }

  /**
   * Merge a single uselist into the fremap and timemap, which can be used in arranging the
   * ecosystem.
   * 
   * @param name the name of the app you want to merge.
   * @param uselist the corresponding uselist of the app.
   * @param fremap the frequence map you want to merge to.
   * @param timemap the time map you want to merge to.
   * @return true if the progress succeed, false otherwise.
   */
  private boolean mergeSingle(String name, List<Integer> uselist, HashMap<String, Integer> fremap,
      HashMap<String, Integer> timemap) {
    int unmergefreq = 0;
    int unmergetime = 0;
    for (Integer i : uselist) {
      unmergefreq++;
      unmergetime += i.intValue();
    }
    if (fremap.containsKey(name)) {
      int totalfre = fremap.get(name).intValue() + unmergefreq;
      int totaltime = timemap.get(name).intValue() + unmergetime;
      fremap.put(name, totalfre);
      timemap.put(name, totaltime);
    } else {
      fremap.put(name, unmergefreq);
      timemap.put(name, unmergetime);
    }
    return true;
  }

  /**
   * Test if two apps in the same orbit is legal according to the rules of the system.
   * 
   * @param c The circular orbit two apps in.
   * @param appname1 One app you want to test with.
   * @param appname2 Another app you want to test with.
   * @param orbitlistindex the index of the orbit in the orbit list.
   * @return true if the progress succeed, false otherwise.
   */
  public boolean synthensisLegal(CircularOrbit<User, PersonalApp> c, String appname1,
      String appname2, int orbitlistindex) {
    List<HashSet<PersonalApp>> objlist = c.getObjOnTracks();
    List<AppUseNote> notelist = this.ecos.get(orbitlistindex - 1);
    AppUseNote note1 = null;
    AppUseNote note2 = null;
    for (AppUseNote note : notelist) {
      if (note.getName().equals(appname1)) {
        note1 = note;
      }
      if (note.getName().equals(appname2)) {
        note2 = note;
      }
    }
    int app1track = 0;
    int app2track = 0;
    PersonalApp app1 = this.apps.get(appname1);
    PersonalApp app2 = this.apps.get(appname2);
    for (int i = 1; i <= objlist.size(); i++) {
      Set<PersonalApp> set1 = objlist.get(i - 1);
      for (PersonalApp p : set1) {
        if (p.getName().equals(appname1)) {
          app1track = i;
        }
        if (p.getName().equals(appname2)) {
          app2track = i;
        }
      }
      /*
       * if(set1.contains(app1)) { app1track=i; } if(set1.contains(app2)) { app2track=i; }
       */
    }
    int syn1 = note1.getSynthesize();
    int syn2 = note2.getSynthesize();
    if (app1track > app2track) {
      if (syn2 > syn1) {
        return true;
      }
    }
    if (app1track < app2track) {
      if (syn2 < syn1) {
        return true;
      }
    }
    if (app1track == app2track) {
      return true;
    }
    return false;
  }

}

class HashMapPool{
  private List<Boolean> valid=new ArrayList<>();
  private List<HashMap<String,Integer>> pool=new ArrayList<>();
  private int size=0;
  //true means available
  HashMap<String,Integer> getHashMap(){
    for(int i=0;i<size;i++) {
      if(valid.get(i)==true) {
        valid.set(i, false);
        return pool.get(i);
      }
    }
    HashMap<String,Integer> newmap=new HashMap<>();
    valid.add(false);pool.add(newmap);size++;
    return newmap;
  }
  
  boolean returnHashMap(HashMap<String,Integer> retmap) {
    for(int i=0;i<size;i++) {
      if(pool.get(i)==retmap) {
        retmap.clear();
        valid.set(i, false);
        return true;
      }
    }
    System.out.print("error in returning the hashmap");
    return false;
  }
}

class HashMapPoolAdvanced{
  private List<HashMap<String,Integer>> busypool=new LinkedList<>();
  private List<HashMap<String,Integer>> freepool=new LinkedList<>();
  private int busysize=0;

  HashMap<String,Integer> getHashMap(){
    if(freepool.size()!=0) {
      HashMap<String,Integer> retmap=freepool.remove(0);
      return retmap;
    }
    HashMap<String,Integer> newmap=new HashMap<>();
    busypool.add(newmap);busysize++;
    return newmap;
  }
  
  boolean returnHashMap(HashMap<String,Integer> retmap) {
    for(int i=0;i<busysize;i++) {
      if(busypool.get(i)==retmap) {
        busypool.remove(i);busysize--;
        retmap.clear();
        freepool.add(retmap);
        return true;
      }
    }
    System.out.print("error in returning the hashmap");
    return false;
  }
}
